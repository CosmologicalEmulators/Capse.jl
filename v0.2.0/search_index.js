var documenterSearchIndex = {"docs":
[{"location":"api/#API-reference","page":"API","title":"API reference","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Capse.CℓEmulator\nCapse.get_Cℓ\nCapse.get_ℓgrid","category":"page"},{"location":"api/#Capse.CℓEmulator","page":"API","title":"Capse.CℓEmulator","text":"CℓEmulator(TrainedEmulator::AbstractTrainedEmulators, ℓgrid::Array,\nInMinMax::Matrix, OutMinMax::Matrix)\n\nThis is the fundamental struct used to obtain the C_ell's from an emulator. It contains:\n\nTrainedEmulator::AbstractTrainedEmulators, the trained emulator\nℓgrid::Array, the ell-grid the emulator has been trained on.\nInMinMax::Matrix, the Matrix used for the MinMax normalization of the input features\nOutMinMax::Matrix, the Matrix used for the MinMax normalization of the output features\n\n\n\n\n\n","category":"type"},{"location":"api/#Capse.get_Cℓ","page":"API","title":"Capse.get_Cℓ","text":"get_Cℓ(CℓEmulator::AbstractCℓEmulators)\n\nComputes and returns the C_ellon the ell-grid the emulator has been trained on.\n\n\n\n\n\n","category":"function"},{"location":"api/#Capse.get_ℓgrid","page":"API","title":"Capse.get_ℓgrid","text":"get_ℓgrid(CℓEmulator::AbstractCℓEmulators)\n\nReturns the ell-grid the emulator has been trained on.\n\n\n\n\n\n","category":"function"},{"location":"#Capse.jl","page":"Home","title":"Capse.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Plots; gr()\nPlots.reset_defaults()\nusing JSON\nusing BenchmarkTools\nusing Capse\ndefault(palette = palette(:tab10))\nbenchmark = BenchmarkTools.load(\"./assets/capse_benchmark.json\")\npath_json = \"./assets/nn_setup.json\"\nweights = rand(20000)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Capse.jl is a Julia package designed to emulate the computation of the CMB Angular Power Spectrum, with a speedup of several orders of magnitude.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In order to install  Capse.jl, run on the Julia REPL","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg, Pkg.add(url=\"https://github.com/CosmologicalEmulators/Capse.jl\")","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you wanna use Capse.jl you need to load a trained emulator. We recommend to instantiate a trained Capse-jl emulator in the following way.","category":"page"},{"location":"","page":"Home","title":"Home","text":"First of all, instantiate a neural network with its weights and biases. This is done through a method imported through the upstream library AbstractCosmologicalEmulators.jl. In order to use it, you need a dictionary containg the information to instantiate the right neural network architecture and an array containing the weights and the biases (both of them can be found on Zenodo and we plan to release more of them). At the given link above, you can find a JSON file with the aforementioned NN architecture. This can be read using the JSON library in the following way","category":"page"},{"location":"","page":"Home","title":"Home","text":"NN_dict = JSON.parsefile(path_json);","category":"page"},{"location":"","page":"Home","title":"Home","text":"This file contains all the informations required to correctly instantiate the neural network.","category":"page"},{"location":"","page":"Home","title":"Home","text":"After this, you just have to pass the NN_dict and the weights array to the init_emulator method and choose a NN backend. In this moment we support two different Neural Networks libraries:","category":"page"},{"location":"","page":"Home","title":"Home","text":"SimpleChains, which is taylored for small NN running on a CPU\nLux, which can run on a GPU","category":"page"},{"location":"","page":"Home","title":"Home","text":"In order to instantiate the emulator, just run","category":"page"},{"location":"","page":"Home","title":"Home","text":"trained_emu = Capse.init_emulator(NN_dict, weights, Capse.SimpleChainsEmulator)","category":"page"},{"location":"","page":"Home","title":"Home","text":"SimpleChains.jl is faster expecially for small NN on the CPU. If you prefer to use Lux.jl, pass as last argument Capse.LuxEmulator.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Each trained emulator should be shipped with a description within the JSON file. In order to print the description, just runs:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Capse.get_emulator_description(NN_dict[\"emulator_description\"])","category":"page"},{"location":"","page":"Home","title":"Home","text":"After instantiating the NN, we need:","category":"page"},{"location":"","page":"Home","title":"Home","text":"the ell-grid used to train the emulator, ℓgrid\nthe arrays used to perform the minmax normalization of both input and output features, InMinMax_array and OutMinMax_array","category":"page"},{"location":"","page":"Home","title":"Home","text":"Now you can instantiate the emulator, using","category":"page"},{"location":"","page":"Home","title":"Home","text":"Cℓ_emu = Capse.CℓEmulator(TrainedEmulator = trained_emu, ℓgrid = ℓgrid,\n                          InMinMax = InMinMax_array, OutMinMax = OutMinMax_array)","category":"page"},{"location":"","page":"Home","title":"Home","text":"After loading a trained CℓTT_emu, feed it some input parameters x.","category":"page"},{"location":"","page":"Home","title":"Home","text":"x = rand(6) # generate some random input\nCapse.get_Cℓ(x, Cℓ_emu) #compute the Cℓ's","category":"page"},{"location":"","page":"Home","title":"Home","text":"warning: Warning\nIn this moment the API is not stable: we need to pass the input cosmological parameters in an hardcoded way. We are working to add a more stable and flexible API.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Using SimpleChains.jl, we obtain a mean execution time of 45 microseconds","category":"page"},{"location":"","page":"Home","title":"Home","text":"benchmark[1][\"Capse\"][\"SimpleChains\"] # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"Using Lux.jl, with the same architecture and weights, we obtain","category":"page"},{"location":"","page":"Home","title":"Home","text":"benchmark[1][\"Capse\"][\"Lux\"] # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"SimpleChains is about 2 times faster than Lux and they give the same result up to floating point precision.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This benchmarks have been performed locally, with a 12th Gen Intel® Core™ i7-1260P.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Considering that a high-precision settings calculation performed with CAMB on the same machine requires around 60 seconds, Capse.jl is around 1000000 times faster.","category":"page"},{"location":"#Authors","page":"Home","title":"Authors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Marco Bonici, INAF - Institute of Space Astrophysics and Cosmic Physics (IASF), Milano\nFederico Bianchini, PostDoctoral researcher at Stanford\nJaime Ruiz-Zapatero, PhD Student at Oxford","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pull requests are welcome. For major changes, please open an issue first to discuss what you would like to change.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Please make sure to update tests as appropriate.","category":"page"},{"location":"#License","page":"Home","title":"License","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Capse.jl is licensed under the MIT \"Expat\" license; see LICENSE for the full license text.","category":"page"}]
}
